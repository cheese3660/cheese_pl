IDEAS:
'in' operator, that returns whether a value is in a range, will reduce to a loop and maybe optimized further.
destructuring for 'for' loops


TODO:
[X] Make newlines end statements in the parser, such that we can return to a normal function call and object syntax
[X] Have tuple literals that are different from struct literals, .{} vs .(), and also array literals .[]
[S] Do the same .{:TYPE} or .[:TYPE] if the type cant be inferred for the literal
    - Skipped cuz tuple type information has been changed
[X] - Syntax error recovery...
[ ] Have '...' function params that can get globbed into a tuple with the name ... basically (internally these parameters are passed as a tuple)
[X] figure out how to link LLVM
[X] internally tuples and structures are basically the same still
[ ] still units
[X] interfaces
[X] concepts
[ ] refactor using modules
[ ] refactor std::map -> std::unordered_map
[ ] refactor ComptimeValue ->  ComptimeValue.h/cpp
[ ] A whole shit ton of curdle tests



ROADMAP:
[X] Lexer
[X] AST
    [X] Use better representation with virtual classes and std::shared_ptr
[ ] Translator
[ ] Lowerer
    [ ] Redeveloping Representation
[ ] LLVM Shit
    [X] Linking LLVM


Error Handling Thoughts:
Have the error type as error(T,[E]) which looks like a function call but is in fact an error type
Return .error(E) or .error stores where it was called as an address (for later printout by the standard library)
try
{
    /* multiple functions that return an error(T,E) */
    /* if I add an errdefer in this scope, then errdefer goes to the end of here instead of the function
} catch E -> name
{

} catch void -> name
{
    /* this is where there is no wrapped value */
}
Any Type of error not caught by a catch statement gets returned and passed upwards yet again
